13 - Hello World
type HelloWorld = string // expected to be a string

4 - 实现 Pick
type MyPick<T, K extends keyof T> = { [P in K]: T[P] }

7 - 实现 Readonly
type MyReadonly<T> = { readonly [P in keyof T]: T[P] }

11 - 元组转换为对象
type TupleToObject<T extends readonly PropertyKey[]> = { [P in T[number]] : P }

14 - 第一个元素
type First<T extends any[]> = T['length'] extends 0 ? never : T[0]

18 - 获取元组长度
type Length<T extends readonly any[]> = T['length'] 

43 - Exclude
type MyExclude<T, U> = T extends U ? never : T

189 - Awaited
type Awaited<T extends Promise<any>> = T extends Promise<infer R> ? R :never

268 - If
type If<C extends Boolean, T, F> = C extends true ? T : F

533 - Concat
type Concat<T extends any[], U extends any[]> = [...T, ...U]

898 - Includes
type Includes<T extends readonly any[], U> = U extends T[keyof T] ? true : false

3057 - Push
type Push<T extends any[], U> = [...T, U]

3060 - Unshift
type Unshift<T extends any[], U> = [U, ...T]

3312 - Parameters
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer R) => any ? R : never

2 - 获取函数返回类型
type MyReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never

3 - 实现 Omit
type MyOmit<T, K extends keyof T> = { [P in keyof T as P extends K ? never: P]: T[P] }

8 - Readonly 2
type MyReadonly2<T, K extends keyof T = keyof T> = { [P in Exclude<keyof T, K>]: T[P] } & { readonly [P in K]: T[P] }

9 - 深度 Readonly
type DeepReadonly<T> = { readonly [P in keyof T]: keyof T[P] extends never ? T[P] : DeepReadonly<T[P]> }

10 - 元组转合集
type TupleToUnion<T extends any[]> = T[number]
